# -*- coding: utf-8 -*-
"""Python_Ciberseguridad.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MVT_LwOlcOTF94R36otPwmLmihK6oMpt
"""

print("Hola soy Deni", "Soy estudiante de la carrera de ingeniera de Software", "Hoy estoy tratando de aprennder ciberseguridad", sep = " - ") #Usando un seperador
print("Estoy aprendiendo Ciberseguridad desde 0 a experto con un curso que costó 320soles en Udemy", "El curso esta interesante", end = " \n\n")#Usamos end para verificar los saltos de linea
print("Eso es todo por este bloque")

#Funcion input
input("Introduce tu nombre: ")
print(input("Introduce tu nombre"), "bienvenido al curso de python")#Combinamos print con input

#Practia N°1 de Python
print("Diario de un Astronauta", end = "\n\n")
print("Fecha: 2024-01-10")
print("Hoy experimentamos con el cultivo de planta\nen microgravedad.")
print("Mensaje personal:¡Es increíble ver cómo\ncrecen las lechugas aquí arriba!",end="\n\n")
print("Fecha: 2024-01-11")
print("Realizamos una caminata espacial para\nreparar un panel solar.")
print("Mensaje personal: Flotar en el espacio nunca\ndeja de asombrarme.")

#Tipos de datos básicos en python
print("Deni")#String con comillas dobles
print('Hola Denilson')#String con comillas simples
print("Denilson\nMorales\nMallqui")#Saltos de línea
print("""Denilson
Morales
Mallqui""")#Forma de imprimir string con 3 saltos de línea
print(10)#Numero entero
print("10")#String
print(type(10))#Nos informa del tipo de de dato
print(type("10"))

#Usamos ahora f'strings
print(f"Cadena de texto combinada con un numero {10}")
print("Cadena de texto combinada con un numero",10)
print(f"El numero 10.5 es de tipo : {type(10.5)}")

#Declaracion de la variable nombre
nombre_astronauta = "Max"
edad_astronauta = 25
destino =  "Marte"
combustible = 85
velocidad = 2700

#Imprimiendo en pantalla
print("Diario de un Astronauta\n\n")
print(f"Hola,soy {nombre_astronauta}, tengo {edad_astronauta} años y mi próximo destino es {destino}.")
print(f"Estoy navegando a {velocidad} km/s con {combustible}% de combustible restante hacia {destino}.\n")

print("Fecha: 2024-01-10")
print("Hoy experimentamos con el cultivo de plantas en microgravedad.")
print("Mensaje personal: ¡Es increíble ver cómo crecen las lechugas aquí arriba!\n")

print("Fecha: 2024-01-11")
print("Realizamos una caminata espacial para reparar un panel solar.")
print("Mensaje personal: Flotar en el espacio nunca deja de asombrarme")

#Tipos de datos complejos en python
#Listas en python
#La listas respetan el orden
lista = ["tarea1", "tarea2","tarea3"]
print(lista)
print(type(lista))

lista_numeros = [1,2,3,4,5]
print(lista_numeros)

lista_combinada = ["tarea1",4,"tarea2",5, [1,2,3,4,5]]#Lista dentro de otra lista
print(lista_combinada)

#Tupla
#Las tuplas son inmutables, es decir que los elementos de la tupla no se pueden modificar
#Usamos para ejecuciones rápidas
#Se recomienda usar tuplas , si los elementos son constantes
tupla = ("tarea1","tarea2","tarea3")
print(type(tupla))
print(tupla)

#Diccionarios
diccionario = {
    "tarea1": "pendiente",
    "tarea2": "en proceso",
    "tarea3": "terminada"
}

print(type(diccionario))
print(diccionario)

#Indexing,Slicing y Stride
#Lista de tareas
lista_tareas = ["tarea1", "tarea2", "tarea3", "tarea4","tarea5"]
#Tupla de tareas
tupla_tareas = ("tarea1", "tarea2", "tarea3", "tarea4", "tarea5")
#Diccionario de tareas
dic_tareas = {
    "tarea1": "pendiente",
    "tarea2": "en proceso",
    "tarea3": "pendiente",
    "tarea4": "terminada",
    "tarea5": "en proceso"
}

#Indexing
print(lista_tareas[-1])#Indexing para listas
print(lista_tareas[1][1])#Aquí accedo al elemento "tarea2" y obtengo la letra a
print(tupla_tareas[3])#Indexing para tuplas
#Indexing para diccionarios
print(dic_tareas["tarea1"])

#Slicing, permite extraer subcadenas
lista_tareas[1:3]#Rango desde 1 a 3 , se extraen 2 elementos 1 , 2
print(lista_tareas[1:3])

#Stride
print(lista_tareas[0::2])#Saldos
#Modificar elementos
lista_tareas[2] = "tarea especial"
print(lista_tareas)

#Modificar diccionario
dic_tareas["tarea2"]= "terminada"
print(dic_tareas)

#Indexing,Slicing y Stride
#Lista de útiles
lista_utiles = ["borrador", "cuadernos" , "lapiceros", "folders", "mochilas"]
#Tupla de útiles
tupla_utiles = ("borrador", "cuadernos", "lapiceros", "folders", "mochilas")
#Diccionario de utiles
dic_utiles = {
    "borrador": "pendiente",
    "cuadernos": "comprado",
    "lapiceros": "en proceso",
    "folders" : "en proceso",
    "mochilas" : "comprado"
}
#Indexing
print(lista_utiles[-1])
print(tupla_utiles[1])
print(dic_utiles["borrador"])
#Slicing
print(lista_utiles[0:2])
print(tupla_utiles[4:5])
#Stride
print(lista_utiles[0::1])
#Modificar elementos
lista_utiles[0] = 'Lapices'
dic_utiles["borrador"]='comprado'
print(lista_utiles)
print(dic_utiles)

#Practica de listas , tuplas , diccionarios
#Lista platos
platos = ["Paella","Risotto","Sushi","Tacos","Pizza"]
#Tuplas precios
precios=(15,12,20,10,8)
#Usamos slicing
platos_seleccionados = platos[1:4]
#Diccionario
menu = {
    platos[0] : precios[0],
    platos[1] : precios[1],
    platos[2] : precios[2],
    platos[3] : precios[3],
    platos[4] : precios[4]
}

menu_descripcion = (
    f"Bienvenidos a nuestro menú especial:\n"
    f"-Paella: {precios[0]} euros\n"
    f"-Risotto: {precios[1]} euros\n"
    f"-Sushi: {precios[2]} euros\n"
    f"-Tacos: {precios[3]} euros\n"
    f"-Pizza: {precios[4]} euros\n"
)

print(menu_descripcion)
#Stride
platos_pares = platos[0::2]
print(f"El tercer plato es {platos[2]} y su precio es {precios[2]}")
print(f"Los platos pares son:{platos_pares}")

#Operadores aritméticos, Comparación y Asignación
#Declaracion de variables
numeros_1 = 10
numeros_2 = 5

string_1 = "Texto1"
string_2 = "Texto2"

lista_1 = ["valor1", "valor2", "valor3"]
lista_2 = ["valor4", "valor5", "valor6"]

tuplas_1 = ("valor1","valor2","valor3")
tuplas_2 = ("valor4","valor5","valor6")
dic_1 = {"clave1":"valor1", "clave2":"valor2"}
#Los operadores artiméticos no se pueden usar con diccionarios
dic_2 = {"clave3":"valor3", "clave4":"valor4"}
#Operadores aritméticos
print("Suma de variables: ",numeros_1 + numeros_2)#Suma
print("Resta de variables:",numeros_1 - numeros_2)#Resta
print("Multiplicacion de variables:",numeros_1 * numeros_2)#Multiplicacion
print("Division de variables:",numeros_1 / numeros_2)#Division
print("Modulo de variables:", numeros_1 % numeros_2)
print("Potencia de variables:",numeros_1 ** numeros_2)#Potencia
print(string_1 , string_2)
print(string_1 + " " + string_2)
print(string_1 + string_2) #Concatenacion
print(lista_1 + lista_2) #Concatenacion de listas
print(tuplas_1 + tuplas_2)

#Operadores de comparacion
print(numeros_1 > numeros_2)
print(numeros_1 == numeros_2)
print(string_1 > string_2) # Comparacion ASCII de su letra inicial
print(string_1 == string_2)
#Operadores de asignación
numeros_1 +=7
print(numeros_1)
lista_1 += [1,2,3]
print(lista_1)

#Definicion de variables
puntuacion_pentesting = 7
puntuacion_analisis_vulnerabilidades = 6
puntuacion_desarrollo_exploits = 5
puntuacion_final = 0.0
participante_aprobado = True
distincion_honor = True
#pesos
peso_pentesting = 0.5
peso_analisis_vulnerabilidades = 0.2
peso_desarrollo_exploits = 0.3

puntuacion_final = puntuacion_pentesting * peso_pentesting + puntuacion_analisis_vulnerabilidades * peso_analisis_vulnerabilidades + puntuacion_desarrollo_exploits * peso_desarrollo_exploits

if puntuacion_final >= 5 :
    participante_aprobado = True
else:
    participante_aprobado = False

if puntuacion_final >=10 :
    distincion_honor = True
else:
    distincion_honor = False

#Impresion de datos
print(f"La calificacion final es : {puntuacion_final}")
print(f"¿Participante aprobado?: {participante_aprobado}")
print(f"¿Distincion de honor?: {distincion_honor}")

#Operadores de pertenencia
#Operadores aritméticos, Comparación y Asignación
#Declaracion de variables
numeros_1 = 10
numeros_2 = 5

string_1 = "Texto1"
string_2 = "Texto2"

lista_1 = ["valor1", "valor2", "valor3"]
lista_2 = ["valor4", "valor5", "valor6"]

tuplas_1 = ("valor1","valor2","valor3")
tuplas_2 = ("valor4","valor5","valor6")
#Los operadores artiméticos no se pueden usar con diccionarios
dic_1 = {"clave1":"valor1", "clave2":"valor2"}
dic_2 = {"clave3":"valor3", "clave4":"valor4"}

#_____________________________
#Operadores de pertenencia
#_____________________________
#Busqueda del caracter C en el string_1
print('c' in string_1)
print('x' in string_1)
#Busqueda del caracter de valor 1 en lista_1
print("valor1" in lista_1)
print("valor3" in tuplas_1)

#Operador opuesto
print("valor45" not in lista_1)
#Busquedad en diccionarios
print("clave1" in dic_1)

#_____________________________
#Operadores lógicos
#_____________________________
print(numeros_1 < numeros_2 or string_1 == string_2)
print(not(numeros_1 < numeros_2 or string_1 == string_2))

#_____________________________
#Operadores lógicos
#_____________________________
#Se usan para comparar
print(type(string_1) is str)
print(type(lista_1) is list)

#Practicas Operadores Pertenencia, Lógicos , Identidad
#Declaracion de variables
password = "Testpass1234"
longitud = len(password) >= 8
caracter = "@" not in password and "#" not in password
numero = any(char.isdigit() for char in password)#Se detiene cuando char.isdigit() encuentra un numero
espacios = " " not in password #No contiene espacios

#Verificacion final
cumple_criterios = longitud and caracter and numero and espacios
print(f"Contraseña: {password}")
print(f"¿La contraseña cumple con los criterios establecidos?{cumple_criterios}")

#Declaracion de variables
#Declaracion de la tupla
niveles_amenaza = (
    "bajo", "moderado", "alto" , "crítico"
    )

amenaza_actual = "alto"
print(f"Nivel de amenaza actual:{amenaza_actual}")

if amenaza_actual in niveles_amenaza:
    if amenaza_actual == 'bajo':
        print("Actividad recomendada:Realizar auditorías de seguridad regulares.")
    elif amenaza_actual == 'moderado':
        print("Actividad recomendada:Reforzar la concienciación de los empleados sobre riesgos de Ciberseguridad.")
    elif amenaza_actual == 'alto':
        print("Actividad recomendada:Implementar medidas de seguridad adicionales y revisar accesos.")
    elif amenaza_actual == 'crítico':
        print("Actividad recomendada:Activar el protocolo de respuesta a incidentes.")
else:
    print("Selecciona un nivel de amenza adecuado(bajo,moderado,alto,crítico)")

#Bucles
#Bucle For
lista = ["tarea1", "tarea2","tarea3"]

lista_tareas = {
    "tarea1" : "completada",
    "tarea2" : "pendiente",
    "tarea3" : "en progreso",
    "tarea4" : "completada",
}
#for <variable> in <iterable>
for tarea in lista_tareas:
  print("Estoy trabajando en la tarea:", tarea)
  print("El estado de las tareas es:", lista_tareas[tarea])
#Funcion iter
lista_tareas_itr = iter(lista_tareas)#Pasando de iterable a iterador

print(next(lista_tareas_itr))

#Bucle while
num = 10
while num>0:
  num -=1
  print(num)
  break #Rompe el bucle
#Funcion range
for i in range(20):
  print("Denilson")

#Practica de bucle for
#Paso1
#Lista inventario
inventario = [("Nmap",50,0.5),("Wireshark",30,0.3),("Metasploit",20,0.4),("Burp Suite",15,0.45)]
#Paso2
valor_total = 0
mayor_cantidad ={
    "herramienta": "",
    "cantidad": 0,
    "precio": 0
}

for herramienta,cantidad,precio in inventario:
  valor_total = valor_total + cantidad * precio
  if cantidad > mayor_cantidad["cantidad"]:
    mayor_cantidad["herramienta"] = herramienta
    mayor_cantidad["cantidad"] = cantidad
    mayor_cantidad["precio"] = precio

print(f"Valor total del inventario: {valor_total} eur")
print(f"Herramienta con mayor cantidad de licencias: {mayor_cantidad['herramienta']}({mayor_cantidad['cantidad']})unidades")

#Segunda parte
compra = {
    "Nmap": 5,
    "Wireshark":3
}
precio_total = 0

for herramienta,cantidad,precio in inventario:
  if herramienta in compra:
    precio_total = precio_total + precio * compra[herramienta]

print(f"Precio de la adquisición: {precio_total} eur")

#Bucle while
#Declaracion de variables
fondos = 10000
#Listas
#Positivos son ingresos
#Negativos son gastos
acciones=[2000,-500,300,-50]
#Variable indice
indice = 0
accion_actual=0
print(f"Fondos iniciales: {fondos}")
while indice < len(acciones):
  accion_actual = acciones[indice]#Actualizacion durante la iteracion
  if accion_actual<0 and abs(accion_actual)>fondos:
     print(f"Accion omitida por insuficiente fondos: {accion_actual}")
  else:
    fondos=fondos + accion_actual
    print(f"Acción procesada: {accion_actual}.Fondos actuales: {fondos}")
  indice = indice + 1#indice+=1
print(f"Fondos finales después de las acciones:{fondos}")

#Funciones en python
def mi_funcion(arg1,arg2):
  print(arg1)
  print(arg2)

#Argumentos posicionales
def suma(arg1,arg2):
  print(arg1 + arg2)
  #Parametros con palabras clave
#def mi_funcion(arg1=8,arg2=9):
  #print(arg1 + arg2)
#mi_funcion("Hola soy Deni", "Hola soy Sebastian")

def mi_funcion(arg1, arg2="valor por defecto"):
  print(arg1)
  print(arg2)
suma(8,9)
mi_funcion(8,"valor 2")#Reemplazo a valor por defecto

#Usamos return
def funcion_retorno(arg1,arg2):
  print(arg1)
  print(arg2)
  return 10

valor_retorno = funcion_retorno("Deni","Sebas")
print(valor_retorno)

#Cifrado César con Python
alfabeto = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']

def cifrado_cesar(texto,desplazamiento):
  texto_cifrado = ""
  for letra in texto:
    if letra in alfabeto:
      indice_actual = alfabeto.index(letra)
      nuevo_indice =(indice_actual + desplazamiento) % len(alfabeto)
      texto_cifrado = texto_cifrado + alfabeto[nuevo_indice] #Agregando la nueva letra
    elif letra in [" ",",",".",":"]:
      texto_cifrado = texto_cifrado + letra
    else:
      return"Todos los caracteres deben estar en mayúsculas y dentro del alfabeto."
  return texto_cifrado

#Funcion para descifrar
def descifrado_cesar(texto, desplazamiento):
    texto_descifrado = ""  # Almacena el resultado
    for caracter in texto:
        if caracter in alfabeto:  # Si es una letra mayúscula
            indice_actual = alfabeto.index(caracter)  # Encuentra el índice actual
            nuevo_indice = (indice_actual - desplazamiento) % len(alfabeto)  # Calcula el nuevo índice
            texto_descifrado += alfabeto[nuevo_indice]  # Agrega la nueva letra
        elif caracter in [" ", ",", ".", ":"]:  # Si es un espacio o signo de puntuación
            texto_descifrado += caracter  # Lo agrega directamente
        else:  # Si no es válido
            return "Todos los caracteres deben estar en mayúsculas y dentro del alfabeto."
    return texto_descifrado


#PRUEBAS
texto_plano = "HOLA MUNDO."
desplazamiento = 3
texto_cifrado = cifrado_cesar(texto_plano,desplazamiento)
texto_descifrado = descifrado_cesar(texto_cifrado,desplazamiento)
texto_invalido = "hola mundo."
resultado_invalido = cifrado_cesar(texto_invalido,desplazamiento)
print("Proceso de cifrado:")
print(f"-Texto plano:{texto_plano}")
print(f"-Texto cifrado:{texto_cifrado}")

print("Proceso de descifrado: ")
print(f"-Texto cifrado:{texto_cifrado}")
print(f"-Texto descifrado:{texto_descifrado}")

print(f"Prueba con texto en minúsculas:")
print("-",resultado_invalido)

#Usando doc_strings
alfabeto = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']

def cifrado_cesar(texto, desplazamiento):
    """
    Cifra un texto utilizando el método del cifrado César.

    Args:
        texto (str): El texto a cifrar.
        desplazamiento (int): El número de posiciones que cada letra del texto
            será desplazada a lo largo del alfabeto.

    Returns:
        str: El texto cifrado si todos los caracteres son válidos (mayúsculas y dentro del alfabeto).
        str: Un mensaje de error si algún carácter no es válido.

    Ejemplo:
        >>> cifrado_cesar("HOLA MUNDO.", 3)
        'KROD PXQGR.'
    """
    texto_cifrado = ""

    # Verificar si todos los caracteres son válidos antes de procesar
    for letra in texto:
        if letra not in alfabeto and letra not in [" ", ",", ".", ":"]:
            return "Todos los caracteres deben estar en mayúsculas y dentro del alfabeto."

    # Procesar el cifrado
    for letra in texto:
        if letra in alfabeto:
            indice_actual = alfabeto.index(letra)
            nuevo_indice = (indice_actual + desplazamiento) % len(alfabeto)
            texto_cifrado += alfabeto[nuevo_indice]
        else:
            texto_cifrado += letra

    return texto_cifrado


def descifrado_cesar(texto_cifrado, desplazamiento):
    """
    Descifra un texto que ha sido cifrado utilizando el método del cifrado César.

    Args:
        texto_cifrado (str): El texto a descifrar.
        desplazamiento (int): El número de posiciones que cada letra fue desplazada
            a lo largo del alfabeto durante el cifrado.

    Returns:
        str: El texto descifrado si todos los caracteres son válidos (mayúsculas y dentro del alfabeto).
        str: Un mensaje de error si algún carácter no es válido.

    Ejemplo:
        >>> descifrado_cesar("KROD PXQGR.", 3)
        'HOLA MUNDO.'
    """
    texto_descifrado = ""

    # Verificar si todos los caracteres son válidos antes de procesar
    for letra in texto_cifrado:
        if letra not in alfabeto and letra not in [" ", ",", ".", ":"]:
            return "Todos los caracteres deben estar en mayúsculas y dentro del alfabeto."

    # Procesar el descifrado
    for letra in texto_cifrado:
        if letra in alfabeto:
            indice_actual = alfabeto.index(letra)
            nuevo_indice = (indice_actual - desplazamiento) % len(alfabeto)
            texto_descifrado += alfabeto[nuevo_indice]
        else:
            texto_descifrado += letra

    return texto_descifrado

# PRUEBA DEL MÉTODO help()
help(cifrado_cesar)

#Scope en python
#Scope local y Scope no local
#No se puede acceder a scopes internos desde scopes externos
#Scope global
scope_global = "Soy un scope_global"
def fun():
  num=10
  print(scope_global)
  def fun2():
    num2 = 20
    print(num2)
    print(num)
  fun2()

fun()
#No puedes acceder a variables externas mas no modificarlas
for i in range(0,3):
  print(locals())#Para ver los elementos de los scopes locales
  print(scope_global)

#Python practica scope
#Manejo de variables locales y globales
#Variable global
puntos_globales = 0
#Definicion de una funcion en python
def registro_puntos():
  #Variable local y externa para la subfuncion bonus_puntos
  puntos_partida = 100
  #Subfuncion
  def bonus_puntos():
    nonlocal puntos_partida
    bonus = 10
    puntos_partida = puntos_partida + bonus
    print(f"Bonus aplicado:{bonus}.Puntos de partida después del bonus:{puntos_partida}")

  #Aplicar el bonus
  bonus_puntos()

  #Modificar la variable local
  global puntos_globales
  puntos_globales = puntos_globales + puntos_partida
  print(f"Puntos de partida:{puntos_partida},Puntos globales después de la partida:{puntos_globales}")

registro_puntos()
print(f"Estado final-Puntos globales:{puntos_globales}")

#Practica de python
class Vulnerabilidad:
  def __init__(self,nombre,severidad,descripcion):
    if severidad not in ["Baja","Media","Alta","Crítica"]:
      print("Error: La severidad debe de ser 'Baja','Media','Alta','Crítica'")
      return
    self.nombre = nombre
    self.severidad = severidad
    self.descripcion = descripcion
    self.recomendacion = ""

  def mostrar_info(self):
    print(f"Nombre:{self.nombre}")
    print(f"Severidad:{self.severidad}")
    print(f"Descripcion:{self.descripcion}")

  def recomendar_acciones(self):
    if self.severidad == "Crítica":
      self.recomendacion = "Aplicar parches de seguridad inmediatamente y revisar sistemas afectados."
    elif self.severidad == "Alta":
      self.recomendacion = "Realizar una auditoría de seguridad y aplicar medidas correctivas lo antes posible."
    elif self.severidad == "Media":
      self.recomendacion = "Monitorizar la actividad del sistema y planificar la aplicación de parches."
    elif self.severidad == "Baja":
      self.recomendacion = "Mantener bajo observación y revisar en el próximo ciclo de actualización."
    print(f"Acción Recomendada:{self.recomendacion}")


#Creacion de objetos
vulnerabilidad1 = Vulnerabilidad("SQL Injection","Alta","Permite la ejecución de consultas SQL no autorizadas.")
vulnerabilidad2 = Vulnerabilidad("XSS","Media","Permite la ejecución de scripts en el navegador del usuario.")
vulnerabilidad3 = Vulnerabilidad("Desbordamiento de Buffer","Crítica","Permite la ejecución arbitraria de código.")

registro_vulnerabilidades = [vulnerabilidad1,vulnerabilidad2,vulnerabilidad3]

for vulnerabilidad in registro_vulnerabilidades:
  vulnerabilidad.mostrar_info()
  vulnerabilidad.recomendar_acciones()
  print()

#Herecia y manejo de opciones
class Coche():
  """Esta clase representa un coche."""
  def __init__(self,modelo,potencia,consumo):

    self.modelo = modelo
    self.potencia = potencia
    self.consumo = consumo
    self.km_actuales = 0

  def especificaciones(self):
    print("Modelo:",self.modelo,
          f"\nPotencia: {self.potencia} cv",
          f"\nConsumo: {self.consumo} l/100km",
          "\nKilometros actuales:",self.km_actuales)


coche_mercedes = Coche("Mercedes",150,10)
coche_mercedes.km_actuales = 20000
coche_mercedes.especificaciones()

class CocheElectrico(Coche):

  def __init__(self, modelo , potencia ,consumo):
    super().__init__(modelo,potencia,consumo)

#Practica N°14
class Dispositivo:
    def __init__(self, nombre, ubicacion):
        self.nombre = nombre
        self.ubicacion = ubicacion
        self.interfaces = []

    def añadir_interfaz(self, interfaz):
        self.interfaces.append(interfaz)

    def mostrar_info(self):
        print(f"Dispositivo: {self.nombre}, Ubicación: {self.ubicacion}")
        for interfaz in self.interfaces:
            print(f"- Interfaz: {interfaz.nombre}, IP: {interfaz.ip}")

class Interfaz:
    def __init__(self, nombre, ip):
        self.nombre = nombre
        self.ip = ip

class Router(Dispositivo):
    def __init__(self, nombre, ubicacion, modelo):
        super().__init__(nombre, ubicacion)
        self.modelo = modelo

class Switch(Dispositivo):
    def __init__(self, nombre, ubicacion, tipo):
        super().__init__(nombre, ubicacion)
        self.tipo = tipo

# Ejecución del programa
# Crear objeto Router
router = Router("Router1", "Data Center", "Cisco 2901")
router.añadir_interfaz(Interfaz("GigabitEthernet0/0", "192.168.1.1"))
router.añadir_interfaz(Interfaz("GigabitEthernet0/1", "192.168.2.1"))

# Crear objeto Switch
switch = Switch("Switch1", "Oficina Principal", "Capa 3")
switch.añadir_interfaz(Interfaz("FastEthernet0/1", "192.168.1.2"))
switch.añadir_interfaz(Interfaz("FastEthernet0/2", "192.168.1.3"))

# Mostrar información
router.mostrar_info()
switch.mostrar_info()

#Manejo de excepciones
#Paso 1
def validar_contraseña(password):
    try:
        #Al menos 8 caracteres de longitud
        if len(password) < 8:
            raise ValueError("La contraseña no cumple con los criterios establecidos: debe tener al menos 8 caracteres.")
        #Al menos una letra mayúscula.
        if not any(char.isupper() for char in password):
            raise ValueError("La contraseña no cumple con los criterios establecidos: debe contener al menos una letra mayúscula.")
        #Al menos una letra minúscula.
        if not any(char.islower() for char in password):
            raise ValueError("La contraseña no cumple con los criterios establecidos: debe contener al menos una letra minúscula.")
        #Al menos un número
        if not any(char.isdigit() for char in password):
             raise ValueError("La contraseña no cumple con los criterios establecidos: debe contener al menos un número.")
        #Al menos un símbolo especial (por ejemplo, @, #, $, %).
        if not any(char in "@#$%&*!?" for char in password):
            raise ValueError("La contraseña no cumple con los criterios establecidos: debe contener al menos un símbolo especial (por ejemplo, @, #, $, %).")

        #Si pasa todas las validaciones
        return True

    except ValueError as e:
        # Lanza la excepción con el mensaje personalizado
        raise ValueError(str(e))

# Definir una contraseña para probar
password = "contraseña1@"

# Bloque try para validar la contraseña
try:
    print(f"Validando contraseña {password}...")
    if validar_contraseña(password):
        print("La contraseña es segura.")
except ValueError as error:
    print(f"Se ha producido una excepción: {error}")

